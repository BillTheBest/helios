package org.helios.spring.container.templates.hibernate;

// Generated Oct 14, 2008 9:08:52 AM by Hibernate Tools 3.2.0.CR1

import java.io.IOException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.apache.log4j.Logger;
import org.helios.spring.container.templates.Provision;
import org.helios.spring.container.templates.merging.ArgumentMerger;

/**
 * Bean generated by hbm2java
 */
public class Bean implements java.io.Serializable, Provision {

	private static final long serialVersionUID = 6988857308778709913L;
	private int beanId;
	private Context context;
	private String beanName;
	private Set<Property> properties = new HashSet<Property>(0);
	private Set<MergerBean> mergerBeans = new HashSet<MergerBean>(0);
	private Set<Ctor> ctors = new HashSet<Ctor>(0);
	protected transient Logger log = Logger.getLogger(getClass());

	public Bean() {
	}

	public Bean(int beanId, Context context, String beanName) {
		this.beanId = beanId;
		this.context = context;
		this.beanName = beanName;
	}

	public Bean(int beanId, Context context, String beanName,
			Set<Property> properties, Set<MergerBean> mergerBeans,
			Set<Ctor> ctors) {
		this.beanId = beanId;
		this.context = context;
		this.beanName = beanName;
		this.properties = properties;
		this.mergerBeans = mergerBeans;
		this.ctors = ctors;
	}
	
	private void readObject(java.io.ObjectInputStream in)  throws IOException, ClassNotFoundException {
		in.defaultReadObject();
		log = Logger.getLogger(getClass());
	}
    


	public int getBeanId() {
		return this.beanId;
	}

	public void setBeanId(int beanId) {
		this.beanId = beanId;
	}

	public Context getContext() {
		return this.context;
	}

	public void setContext(Context context) {
		this.context = context;
	}

	public String getBeanName() {
		return this.beanName;
	}

	public void setBeanName(String beanName) {
		this.beanName = beanName;
	}

	public Set<Property> getProps() {
		return this.properties;
	}

	public void setProperties(Set<Property> properties) {
		this.properties = properties;
	}

	public Set<MergerBean> getMergerBeans() {
		return this.mergerBeans;
	}

	public void setMergerBeans(Set<MergerBean> mergerBeans) {
		this.mergerBeans = mergerBeans;
	}

	public Set<Ctor> getCtors() {
		return this.ctors;
	}

	public void setCtors(Set<Ctor> ctors) {
		this.ctors = ctors;
	}

	/**
	 * Constructs a <code>String</code> with all attributes
	 * in name = value format.
	 *
	 * @return a <code>String</code> representation 
	 * of this object.
	 */
	public String toString()
	{
	    final String CR = "\n\t";
	    final String CRR = "\n\t\t";
	
	    StringBuilder retValue = new StringBuilder();
	    
	    retValue.append("Bean ( \n")
	        .append(CR).append("beanId:").append(this.beanId)
	    	.append(CR).append("beanName:").append(this.beanName);
	    
	        retValue.append(CR).append("properties:");
	    	for(Property p: properties) {
	    		retValue.append(CRR).append(p.toString());
	    	}
	        retValue.append(CR).append("ctors:");
	    	for(Ctor c: ctors) {
	    		retValue.append(CRR).append(c.toString());
	    	}
	        retValue.append(CR).append("mergers:");
	    	for(MergerBean mb: this.mergerBeans) {
	    		retValue.append(CRR).append(mb.getMerger().toString());
	    	}
	        retValue.append("\n )");
	    
	    return retValue.toString();
	}

	@SuppressWarnings("unchecked")
	public Map<Class, ArgumentMerger> getArgumentMergers() {
		Map<Class, ArgumentMerger> map = new HashMap<Class, ArgumentMerger>();
		if(mergerBeans != null) {
			for(MergerBean mb: mergerBeans) {
				try {
					Class type = Class.forName(mb.getMerger().getClassType());
					Class<ArgumentMerger> amType = (Class<ArgumentMerger>) Class.forName(mb.getMerger().getClassName());
					ArgumentMerger am = amType.newInstance();
					map.put(type, am);
				} catch (Exception e) {
					log.error("Failed to create argumentMergers from MergerBean [" + mb + "]", e);
				}
			}
		}
		return map;
	}

	public Map<Integer, Object> getConstructorArguments() {
		Map<Integer, Object> map = new HashMap<Integer, Object>();
		if(ctors != null) {
			for(Ctor ctor: ctors) {
				map.put(ctor.getSequence(), (ctor.isRef() ? "ref:" :"") + ctor.getValue());
			}
		}
		return map;
	}

	public String getContextName() {		
		return context.getContextName();
	}

	public Map<String, Object> getProperties() {
		Map<String, Object> map = new HashMap<String, Object>();
		if(properties != null) {
			for(Property prop: properties) {
				map.put(prop.getName(), (prop.isRef() ? "ref:" :"") +  prop.getValue());
			}
		}
		return map;
	}

}
